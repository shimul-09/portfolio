 import * as Framer from "framer"; import * as React from "react"; import { createPortal } from "react-dom"; import * as ReactDOM from "react-dom/client"; const routes = {augiA20Il: {elements: {ZdN4BMTCW: "start"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/ySvg1VVcKYgcZWgvPZ0y/w2nUvyCjIQO6xrmR9NUU/augiA20Il.js")),
path: "/"}, j93N9b4fR: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/H6e4mcORuX9wFHL8XDVO/9Gx2sJ6gniCVknoP4mcc/j93N9b4fR.js")), path: "/about"}, tHHaIRiP9: {elements: {FRw_bJq2v: "start"}, page: Framer.lazy(() =>
import("https://framerusercontent.com/modules/83gHgWz4cJJiwbSEsgT2/zArUtZH3XgWfWDSmVEKR/tHHaIRiP9.js")), path: "/blog"}, DCj1AYyS_: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/dQKLNUCuCOnyHpNIbxgW/gPc3k5aqKb4MvncVf2vm/DCj1AYyS_.js")),
path: "/contact"}, hdftlc0TT: {collectionId: "gtdxwHKf6", elements: {K13TcNi1U: "start"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/jC81L6q0JvEhTv2SzB5T/w03yQmJ1CeqSLMTWteOm/hdftlc0TT.js")), path: "/blog/:HU9VFdZBc"}} const
locales = [{code: "en-US", id: "default", name: "English", slug: ""}] const collectionUtils = {gtdxwHKf6: async () => (await import("https://framerusercontent.com/modules/bA68V52iMORZCiq82iE8/OMUAL9OWLjS3q6i9wQJ1/gtdxwHKf6.js"))?.["utils"]} const framerSiteId
= "8bbf7a377de8b5954aebe153223e40098b9614154bad610e3c073e161a2b59a4" export async function getPageRoot({ routeId, pathVariables, localeId }) { // We don't want the initial render to immediately have to suspend. await routes[routeId].page.preload() const
content = React.createElement( Framer.PageRoot, { isWebsite: true, routeId, pathVariables, routes, collectionUtils, framerSiteId, notFoundPage: Framer.lazy(() => import("__framer-not-found-page")), isReducedMotion: undefined, localeId, locales, preserveQueryParams:
undefined, siteCanonicalURL: undefined, EditorBar: typeof window === "undefined" ? undefined : Framer.lazy(async () => { const { createEditorBar } = await import("https://edit.framer.com/init.mjs") return { default: createEditorBar({ dependencies: { __version:
1, framer: { useCurrentRoute: Framer.useCurrentRoute, useLocaleInfo: Framer.useLocaleInfo, useRouter: Framer.useRouter }, react: { createElement: React.createElement, memo: React.memo, useCallback: React.useCallback, useEffect: React.useEffect, useRef:
React.useRef, useState: React.useState }, 'react-dom': { createPortal } } }) } }) , } ) const contentWithFeaturesContext = React.createElement( Framer.LibraryFeaturesProvider, { children: content, value: {codeBoundaries: true, editorBarSubtle: false,
enableAsyncURLUpdates: true, newTrackingEvents: false, pauseOffscreen: true, replaceNestedLinks: true, useGranularSuspense: true, wrapUpdatesInTransitions: true} } ) const contentWithGracefullyDegradingErrorBoundary = React.createElement(Framer.GracefullyDegradingErrorBoundary,
{ children: contentWithFeaturesContext }) const page = React.createElement(Framer.PageEffectsProvider, { children: contentWithGracefullyDegradingErrorBoundary, value: {routes: {}} }) return page } const isBrowser = typeof document !== "undefined" if (isBrowser)
{ window.__framer_importFromPackage = (packageAndFilename, exportIdentifier) => () => { return React.createElement(Framer.ErrorPlaceholder, { error: 'Package component not supported: "' + exportIdentifier + '" in "' + packageAndFilename + '"' }) } //
A lot of libraries assume process.env.NODE_ENV is present in runtime/buildtime, so we are polyfilling it window.process = { ...window.process, env: { ...(window.process ? window.process.env: undefined), NODE_ENV: "production" } } window.__framer_events
= window.__framer_events || [] // Fallback support for stack gaps Framer.installFlexboxGapWorkaroundIfNeeded() const container = document.getElementById("main") // We know that #main is parsed before this script, so we don't need to wait for DOMContentLoaded
or similar events. if ("framerHydrateV2" in container.dataset) main(true, container) else main(false, container) } function track() { if (!isBrowser) return window.__framer_events.push(arguments) } async function main(shouldHydrate, container) { function
handleError(error, errorInfo, recoverable = true) { if (error.caught || window.__framer_hadFatalError) return // we already logged it const componentStack = errorInfo?.componentStack if (recoverable) { console.warn("Recoverable error during hydration.
Please check any custom code or code overrides to fix server/client mismatches:\n", error, componentStack) // we only want to collect 1%, because this can be quite noisy (floods the data pipeline) if (Math.random() > 0.01) return } else { console.error("Fatal
crash during hydration. If you are the author of this website, please report this issue to the Framer team via https://www.framer.community/") } track(recoverable ? "published_site_load_recoverable_error" : "published_site_load_error", { message: String(error),
componentStack, // componentStack is more useful stack: componentStack ? undefined : error instanceof Error && typeof error.stack === "string" ? error.stack : null, }) } try { let routeId, localeId, pathVariables, breakpoints if (shouldHydrate) { const
routeData = JSON.parse(container.dataset.framerHydrateV2) routeId = routeData.routeId localeId = routeData.localeId pathVariables = routeData.pathVariables breakpoints = routeData.breakpoints } else { const routeData = Framer.inferInitialRouteFromPath(routes,
decodeURIComponent(location.pathname), true, locales) routeId = routeData.routeId localeId = routeData.localeId pathVariables = routeData.pathVariables } const page = await getPageRoot({ routeId, localeId, pathVariables }) if (shouldHydrate) { Framer.withPerformanceMarks("framer-rewrite-breakpoints",
() => { Framer.removeHiddenBreakpointLayersV2(breakpoints) window.__framer_onRewriteBreakpoints?.(breakpoints) }) const startTransition = React.startTransition startTransition(() => { Framer.markHydrationStart() Framer.setInitialHydrationState() if (true)
Framer.turnOffReactEventHandling() ReactDOM.hydrateRoot(container, page, { onRecoverableError: handleError }) }) } else { ReactDOM.createRoot(container, { onRecoverableError: handleError }).render(page) } } catch (error) { handleError(error, undefined,
false) throw error } } ;(function () { if (!isBrowser) return React.startTransition(() => { ReactDOM.createRoot(document.getElementById("__framer-badge-container")).render(React.createElement(React.Suspense, {}, React.createElement(Framer.withStyleAppearEffect(Framer.Container),
{ className: "__framer-badge", __framer__threshold: 0.5, __framer__animateOnce: true, __framer__opacity: 0, __framer__targetOpacity: 1, __framer__rotate: 0, __framer__x: 0, __framer__y: 10, __framer__scale: 1, __framer__transition: { "type": "spring",
"ease": [0.44, 0, 0.56, 1], "duration": 0.3, "delay": 1, "stiffness": 350, "damping": 40, "mass": 1.5 }, __framer__rotateX: 0, __framer__rotateY: 0, __framer__perspective: 1200, }, React.createElement(React.lazy(() => import("__framer-badge"))) ) )) })
})()